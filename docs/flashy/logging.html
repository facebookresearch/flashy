<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flashy.logging API documentation</title>
<meta name="description" content="Logging related utilities." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flashy.logging</code></h1>
</header>
<section id="section-intro">
<p>Logging related utilities.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.
&#34;&#34;&#34;Logging related utilities.
&#34;&#34;&#34;
from argparse import Namespace
from collections.abc import Iterable, Sized
import logging
from pathlib import Path
import sys
import time
import typing as tp

import colorlog
from dora import get_xp
from dora.distrib import get_distrib_spec
from flashy.loggers.base import ExperimentLogger
from flashy.loggers.localfs import LocalFSLogger

from .formatter import Formatter
from .loggers import TensorboardLogger, WandbLogger
from .utils import AnyPath


def setup_logging(
        with_file_log: bool = True,
        folder: tp.Optional[AnyPath] = None,
        log_name: str = &#39;solver.log.{rank}&#39;,
        level: int = logging.INFO):
    &#34;&#34;&#34;Setup logging nicely, we recommend you call this as the very first step,
    not to miss any possible messages. By default this will also create a log file in the experiment folder.

    Args:
        with_file_log: if True, creates a log file in the XP folder,
            or the folder given explicitely. Default is True.
        folder: customize folder to store the logs in.
        log_name: template for the filename of the log. Default is
            `solver.log.{rank}`.
        level: log level, default is `logging.INFO`.
    &#34;&#34;&#34;
    # See https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook for reference.
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.handlers.clear()

    sh = logging.StreamHandler(sys.stderr)
    sh.setLevel(level)

    # Let us switch to colorlog for an improved esthetic experience.
    log_format = (&#39;[%(cyan)s%(asctime)s%(reset)s][%(blue)s%(name)s%(reset)s]&#39;
                  &#39;[%(log_color)s%(levelname)s%(reset)s] - %(message)s&#39;)
    formatter = colorlog.ColoredFormatter(
        log_format,
        datefmt=&#34;%m-%d %H:%M:%S&#34;)

    sh = logging.StreamHandler(sys.stderr)
    sh.setLevel(level)
    sh.setFormatter(formatter)
    root_logger.addHandler(sh)

    if with_file_log:
        if folder is None:
            folder = get_xp().folder
        # We need to get the rank in a reliable way, even if distributed is not yet initialized.
        rank = get_distrib_spec().rank
        fh = logging.FileHandler(Path(folder) / log_name.format(rank=rank))
        fh.setLevel(level)
        fh.setFormatter(formatter)
        root_logger.addHandler(fh)


def colorize(text: str, color: str) -&gt; str:
    &#34;&#34;&#34;ANSI colorization with ANSI escape sequence.
    See: https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences

    Args:
        text (str): text to colorize
        color (str): ANSI color escape sequence
    &#34;&#34;&#34;
    code = f&#34;\033[{color}m&#34;
    restore = &#34;\033[0m&#34;
    return &#34;&#34;.join([code, text, restore])


def bold(text: str) -&gt; str:
    &#34;&#34;&#34;
    Display text in bold in the terminal.
    &#34;&#34;&#34;
    return colorize(text, &#34;1&#34;)


class LogProgressBar:
    &#34;&#34;&#34;Log progress bar for results
    Sort of like tqdm but using log lines and not as real time.

    Args:
        logger (logging.Logger): Logger obtained from `logging.getLogger`
        iterable (Iterable): Iterable object to wrap
        updates (int): Number of lines that will be printed, e.g.
            if `updates=5`, log every 1/5th of the total length
        time_per_it (bool): Force speed to display as ms/it
        total (int): length of the iterable, in case it does not support
            `len`.
        name (str): Prefix to use in the log
        level (int): Logging level (like `logging.INFO`)
        delimiter (str): Delimiter between displayed stats in logs
        items_delimiter (str): Delimiter between key, value items in metrics log
    &#34;&#34;&#34;
    def __init__(self,
                 logger: logging.Logger,
                 iterable: Iterable,
                 updates: int = 5,
                 min_interval: int = 1,
                 time_per_it: bool = False,
                 total: tp.Optional[int] = None,
                 name: str = &#39;LogProgressBar&#39;,
                 level: int = logging.INFO,
                 delimiter: str = &#39;|&#39;,
                 items_delimiter: str = &#39; &#39;,
                 formatter: Formatter = Formatter()):
        self._iterable = iterable
        if total is None:
            assert isinstance(iterable, Sized)
            total = len(iterable)
        self._total = total
        self._updates = updates
        self._min_interval = min_interval
        self._time_per_it = time_per_it
        self._name = name
        self._logger = logger
        self._level = level
        self._delimiter = delimiter
        self._items_delimiter = items_delimiter
        self._formatter = formatter

    def update(self, **metrics) -&gt; bool:
        &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
        happen at the end of this iteration.&#34;&#34;&#34;
        self._metrics = self._formatter(metrics)
        return self._will_log

    def __iter__(self):
        self._iterator = iter(self._iterable)
        self._will_log = False
        self._index = -1
        self._metrics = {}
        self._begin = time.time()
        return self

    def __next__(self):
        if self._will_log:
            self._log()
            self._will_log = False
        try:
            value = next(self._iterator)
        except StopIteration:
            raise
        else:
            self._index += 1
            if self._updates &gt; 0:
                _log_every = max(self._min_interval, self._total // self._updates)
                # logging is delayed by 1 it, in order to have the metrics from update
                if self._index &gt;= 1 and self._index % _log_every == 0:
                    self._will_log = True
            return value

    def _log(self):
        self._speed = (1 + self._index) / (time.time() - self._begin)
        infos = [f&#34;{k}{self._items_delimiter}{v}&#34; for k, v in self._metrics.items()]
        if self._speed &lt; 1e-4:
            speed = &#39;oo sec/it&#39;
        elif self._time_per_it and self._speed &lt; 1:
            speed = f&#39;{1 / self._speed:.2f} sec/it&#39;
        elif self._time_per_it:
            speed = f&#39;{1000 / self._speed:.1f} ms/it&#39;
        elif self._speed &lt; 0.1:
            speed = f&#39;{1/self._speed:.1f} sec/it&#39;
        else:
            speed = f&#39;{self._speed:.2f} it/sec&#39;
        prefix = [f&#39;{self._name}&#39;, f&#39;{self._index}/{self._total}&#39;, f&#39;{speed}&#39;]
        msg = f&#39; {self._delimiter} &#39;.join(prefix + infos)
        self._logger.log(self._level, msg)


class ResultLogger:
    &#34;&#34;&#34;Logger for experiment results.

    Logs summary of training metrics in stdout and media samples
    across the specified platforms experiment loggers.
    &#34;&#34;&#34;

    def __init__(self, logger: logging.Logger, level: int = logging.INFO,
                 delimiter: str = &#39;|&#39;):
        self._logger = logger
        self._level = level
        self._delimiter = delimiter
        self._experiment_loggers: tp.Dict[str, ExperimentLogger] = {}
        self._experiment_loggers[&#39;local&#39;] = LocalFSLogger.from_xp(with_media_logging=True)

    def init_tensorboard(self, **kwargs):
        &#34;&#34;&#34;Initialize Tensorboard logger using dora xp.
        See `flashy.loggers.tensorboard.TensorboardLogger.from_xp` for details
        &#34;&#34;&#34;
        self._experiment_loggers[&#39;tensorboard&#39;] = TensorboardLogger.from_xp(**kwargs)

    def init_wandb(self, **kwargs):
        &#34;&#34;&#34;Initialize Wandb logger using dora xp.
        See `flashy.loggers.wandb.WandbLogger.from_xp` for details
        &#34;&#34;&#34;
        self._experiment_loggers[&#39;wandb&#39;] = WandbLogger.from_xp(**kwargs)

    def log_hyperparams(self, params: tp.Union[tp.Dict[str, tp.Any], Namespace],
                        metrics: tp.Optional[dict] = None) -&gt; None:
        &#34;&#34;&#34;Log hyperparameters to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_hyperparams(params, metrics)

    def get_log_progress_bar(self, stage: str, iterable: Iterable, updates: int = 5, total: tp.Optional[int] = None,
                             step: tp.Optional[int] = None, step_name: tp.Optional[str] = None,
                             **kwargs: tp.Any) -&gt; LogProgressBar:
        &#34;&#34;&#34;Get a progress bar logger formatted for the current stage and iterable.

        Args:
            stage (str): Stage name
            iterable (Iterable): Data to iterate over
            updates (int): Number of updates for the progress bar logging
            total (int): Total size of the data iterated over
            step (int): Number of current steps
            step_name (str): Name for the used steps (eg. `epochs`)
            kwargs: Additional arguments for :class:`~flashy.logging.LogProgressBar` initialization

        Returns:
            `flashy.logging.LogProgressBar`: Progress bar logger
        &#34;&#34;&#34;
        name = [f&#39;{stage.capitalize()}&#39;]
        if step is not None and step_name is not None:
            name += [f&#39;{step_name.capitalize()} {step}&#39;]
        progress_bar_name = f&#39; {self._delimiter} &#39;.join(name)
        return LogProgressBar(self._logger, iterable, updates=updates, total=total,
                              name=progress_bar_name, delimiter=self._delimiter, **kwargs)

    def _log_summary(self, stage: str, metrics: dict,
                     step: tp.Optional[int] = None, step_name: str = &#34;epoch&#34;,
                     formatter: Formatter = Formatter()) -&gt; None:
        &#34;&#34;&#34;Log stage summary of current step with key metrics.

        Args:
            stage (str): Stage name
            metrics (dict): Dictionary of metrics to log (optionally already formatted)
            step (int): Number of current steps
            step_name (str): Name for the used steps (eg. `epochs`)
        &#34;&#34;&#34;
        out = [f&#39;{stage.capitalize()} Summary&#39;]
        if step is not None:
            out += [f&#39;{step_name.capitalize()} {step}&#39;]
        metrics = formatter(metrics)
        out += [f&#34;{key}={val}&#34;.strip() for key, val in metrics.items()]
        msg = f&#39; {self._delimiter} &#39;.join(out)
        self._logger.log(self._level, bold(msg))

    def log_metrics(self, stage: str, metrics: dict, step: tp.Optional[int] = None,
                    step_name: str = &#34;epoch&#34;,
                    formatter: Formatter = Formatter()) -&gt; None:
        &#34;&#34;&#34;Log metrics to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        self._log_summary(stage, metrics, step, step_name, formatter)
        for _, logger in self._experiment_loggers.items():
            logger.log_metrics(stage, metrics, step)

    def log_audio(self, stage: str, key: str, audio: tp.Any, sample_rate: int,
                  step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log audio to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_audio(stage, key, audio, sample_rate, step, **kwargs)

    def log_image(self, stage: str, key: str, image: tp.Any,
                  step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log image to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_image(stage, key, image, step, **kwargs)

    def log_text(self, stage: str, key: str, text: str, step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log text to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_text(stage, key, text, step, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="flashy.logging.bold"><code class="name flex">
<span>def <span class="ident">bold</span></span>(<span>text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Display text in bold in the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bold(text: str) -&gt; str:
    &#34;&#34;&#34;
    Display text in bold in the terminal.
    &#34;&#34;&#34;
    return colorize(text, &#34;1&#34;)</code></pre>
</details>
</dd>
<dt id="flashy.logging.colorize"><code class="name flex">
<span>def <span class="ident">colorize</span></span>(<span>text: str, color: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ANSI colorization with ANSI escape sequence.
See: <a href="https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences">https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to colorize</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>ANSI color escape sequence</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colorize(text: str, color: str) -&gt; str:
    &#34;&#34;&#34;ANSI colorization with ANSI escape sequence.
    See: https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences

    Args:
        text (str): text to colorize
        color (str): ANSI color escape sequence
    &#34;&#34;&#34;
    code = f&#34;\033[{color}m&#34;
    restore = &#34;\033[0m&#34;
    return &#34;&#34;.join([code, text, restore])</code></pre>
</details>
</dd>
<dt id="flashy.logging.setup_logging"><code class="name flex">
<span>def <span class="ident">setup_logging</span></span>(<span>with_file_log: bool = True, folder: Union[pathlib.Path, str, None] = None, log_name: str = 'solver.log.{rank}', level: int = 20)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup logging nicely, we recommend you call this as the very first step,
not to miss any possible messages. By default this will also create a log file in the experiment folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>with_file_log</code></strong></dt>
<dd>if True, creates a log file in the XP folder,
or the folder given explicitely. Default is True.</dd>
<dt><strong><code>folder</code></strong></dt>
<dd>customize folder to store the logs in.</dd>
<dt><strong><code>log_name</code></strong></dt>
<dd>template for the filename of the log. Default is
<code>solver.log.{rank}</code>.</dd>
<dt><strong><code>level</code></strong></dt>
<dd>log level, default is <code>logging.INFO</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logging(
        with_file_log: bool = True,
        folder: tp.Optional[AnyPath] = None,
        log_name: str = &#39;solver.log.{rank}&#39;,
        level: int = logging.INFO):
    &#34;&#34;&#34;Setup logging nicely, we recommend you call this as the very first step,
    not to miss any possible messages. By default this will also create a log file in the experiment folder.

    Args:
        with_file_log: if True, creates a log file in the XP folder,
            or the folder given explicitely. Default is True.
        folder: customize folder to store the logs in.
        log_name: template for the filename of the log. Default is
            `solver.log.{rank}`.
        level: log level, default is `logging.INFO`.
    &#34;&#34;&#34;
    # See https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook for reference.
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.handlers.clear()

    sh = logging.StreamHandler(sys.stderr)
    sh.setLevel(level)

    # Let us switch to colorlog for an improved esthetic experience.
    log_format = (&#39;[%(cyan)s%(asctime)s%(reset)s][%(blue)s%(name)s%(reset)s]&#39;
                  &#39;[%(log_color)s%(levelname)s%(reset)s] - %(message)s&#39;)
    formatter = colorlog.ColoredFormatter(
        log_format,
        datefmt=&#34;%m-%d %H:%M:%S&#34;)

    sh = logging.StreamHandler(sys.stderr)
    sh.setLevel(level)
    sh.setFormatter(formatter)
    root_logger.addHandler(sh)

    if with_file_log:
        if folder is None:
            folder = get_xp().folder
        # We need to get the rank in a reliable way, even if distributed is not yet initialized.
        rank = get_distrib_spec().rank
        fh = logging.FileHandler(Path(folder) / log_name.format(rank=rank))
        fh.setLevel(level)
        fh.setFormatter(formatter)
        root_logger.addHandler(fh)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flashy.logging.LogProgressBar"><code class="flex name class">
<span>class <span class="ident">LogProgressBar</span></span>
<span>(</span><span>logger: logging.Logger, iterable: collections.abc.Iterable, updates: int = 5, min_interval: int = 1, time_per_it: bool = False, total: Optional[int] = None, name: str = 'LogProgressBar', level: int = 20, delimiter: str = '|', items_delimiter: str = ' ', formatter: <a title="flashy.formatter.Formatter" href="formatter.html#flashy.formatter.Formatter">Formatter</a> = &lt;flashy.formatter.Formatter object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Log progress bar for results
Sort of like tqdm but using log lines and not as real time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>Logger obtained from <code>logging.getLogger</code></dd>
<dt><strong><code>iterable</code></strong> :&ensp;<code>Iterable</code></dt>
<dd>Iterable object to wrap</dd>
<dt><strong><code>updates</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines that will be printed, e.g.
if <code>updates=5</code>, log every 1/5th of the total length</dd>
<dt><strong><code>time_per_it</code></strong> :&ensp;<code>bool</code></dt>
<dd>Force speed to display as ms/it</dd>
<dt><strong><code>total</code></strong> :&ensp;<code>int</code></dt>
<dd>length of the iterable, in case it does not support
<code>len</code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Prefix to use in the log</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>Logging level (like <code>logging.INFO</code>)</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str</code></dt>
<dd>Delimiter between displayed stats in logs</dd>
<dt><strong><code>items_delimiter</code></strong> :&ensp;<code>str</code></dt>
<dd>Delimiter between key, value items in metrics log</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogProgressBar:
    &#34;&#34;&#34;Log progress bar for results
    Sort of like tqdm but using log lines and not as real time.

    Args:
        logger (logging.Logger): Logger obtained from `logging.getLogger`
        iterable (Iterable): Iterable object to wrap
        updates (int): Number of lines that will be printed, e.g.
            if `updates=5`, log every 1/5th of the total length
        time_per_it (bool): Force speed to display as ms/it
        total (int): length of the iterable, in case it does not support
            `len`.
        name (str): Prefix to use in the log
        level (int): Logging level (like `logging.INFO`)
        delimiter (str): Delimiter between displayed stats in logs
        items_delimiter (str): Delimiter between key, value items in metrics log
    &#34;&#34;&#34;
    def __init__(self,
                 logger: logging.Logger,
                 iterable: Iterable,
                 updates: int = 5,
                 min_interval: int = 1,
                 time_per_it: bool = False,
                 total: tp.Optional[int] = None,
                 name: str = &#39;LogProgressBar&#39;,
                 level: int = logging.INFO,
                 delimiter: str = &#39;|&#39;,
                 items_delimiter: str = &#39; &#39;,
                 formatter: Formatter = Formatter()):
        self._iterable = iterable
        if total is None:
            assert isinstance(iterable, Sized)
            total = len(iterable)
        self._total = total
        self._updates = updates
        self._min_interval = min_interval
        self._time_per_it = time_per_it
        self._name = name
        self._logger = logger
        self._level = level
        self._delimiter = delimiter
        self._items_delimiter = items_delimiter
        self._formatter = formatter

    def update(self, **metrics) -&gt; bool:
        &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
        happen at the end of this iteration.&#34;&#34;&#34;
        self._metrics = self._formatter(metrics)
        return self._will_log

    def __iter__(self):
        self._iterator = iter(self._iterable)
        self._will_log = False
        self._index = -1
        self._metrics = {}
        self._begin = time.time()
        return self

    def __next__(self):
        if self._will_log:
            self._log()
            self._will_log = False
        try:
            value = next(self._iterator)
        except StopIteration:
            raise
        else:
            self._index += 1
            if self._updates &gt; 0:
                _log_every = max(self._min_interval, self._total // self._updates)
                # logging is delayed by 1 it, in order to have the metrics from update
                if self._index &gt;= 1 and self._index % _log_every == 0:
                    self._will_log = True
            return value

    def _log(self):
        self._speed = (1 + self._index) / (time.time() - self._begin)
        infos = [f&#34;{k}{self._items_delimiter}{v}&#34; for k, v in self._metrics.items()]
        if self._speed &lt; 1e-4:
            speed = &#39;oo sec/it&#39;
        elif self._time_per_it and self._speed &lt; 1:
            speed = f&#39;{1 / self._speed:.2f} sec/it&#39;
        elif self._time_per_it:
            speed = f&#39;{1000 / self._speed:.1f} ms/it&#39;
        elif self._speed &lt; 0.1:
            speed = f&#39;{1/self._speed:.1f} sec/it&#39;
        else:
            speed = f&#39;{self._speed:.2f} it/sec&#39;
        prefix = [f&#39;{self._name}&#39;, f&#39;{self._index}/{self._total}&#39;, f&#39;{speed}&#39;]
        msg = f&#39; {self._delimiter} &#39;.join(prefix + infos)
        self._logger.log(self._level, msg)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="flashy.logging.LogProgressBar.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **metrics) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update the metrics to show when logging. Return True if logging will
happen at the end of this iteration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **metrics) -&gt; bool:
    &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
    happen at the end of this iteration.&#34;&#34;&#34;
    self._metrics = self._formatter(metrics)
    return self._will_log</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="flashy.logging.ResultLogger"><code class="flex name class">
<span>class <span class="ident">ResultLogger</span></span>
<span>(</span><span>logger: logging.Logger, level: int = 20, delimiter: str = '|')</span>
</code></dt>
<dd>
<div class="desc"><p>Logger for experiment results.</p>
<p>Logs summary of training metrics in stdout and media samples
across the specified platforms experiment loggers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultLogger:
    &#34;&#34;&#34;Logger for experiment results.

    Logs summary of training metrics in stdout and media samples
    across the specified platforms experiment loggers.
    &#34;&#34;&#34;

    def __init__(self, logger: logging.Logger, level: int = logging.INFO,
                 delimiter: str = &#39;|&#39;):
        self._logger = logger
        self._level = level
        self._delimiter = delimiter
        self._experiment_loggers: tp.Dict[str, ExperimentLogger] = {}
        self._experiment_loggers[&#39;local&#39;] = LocalFSLogger.from_xp(with_media_logging=True)

    def init_tensorboard(self, **kwargs):
        &#34;&#34;&#34;Initialize Tensorboard logger using dora xp.
        See `flashy.loggers.tensorboard.TensorboardLogger.from_xp` for details
        &#34;&#34;&#34;
        self._experiment_loggers[&#39;tensorboard&#39;] = TensorboardLogger.from_xp(**kwargs)

    def init_wandb(self, **kwargs):
        &#34;&#34;&#34;Initialize Wandb logger using dora xp.
        See `flashy.loggers.wandb.WandbLogger.from_xp` for details
        &#34;&#34;&#34;
        self._experiment_loggers[&#39;wandb&#39;] = WandbLogger.from_xp(**kwargs)

    def log_hyperparams(self, params: tp.Union[tp.Dict[str, tp.Any], Namespace],
                        metrics: tp.Optional[dict] = None) -&gt; None:
        &#34;&#34;&#34;Log hyperparameters to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_hyperparams(params, metrics)

    def get_log_progress_bar(self, stage: str, iterable: Iterable, updates: int = 5, total: tp.Optional[int] = None,
                             step: tp.Optional[int] = None, step_name: tp.Optional[str] = None,
                             **kwargs: tp.Any) -&gt; LogProgressBar:
        &#34;&#34;&#34;Get a progress bar logger formatted for the current stage and iterable.

        Args:
            stage (str): Stage name
            iterable (Iterable): Data to iterate over
            updates (int): Number of updates for the progress bar logging
            total (int): Total size of the data iterated over
            step (int): Number of current steps
            step_name (str): Name for the used steps (eg. `epochs`)
            kwargs: Additional arguments for :class:`~flashy.logging.LogProgressBar` initialization

        Returns:
            `flashy.logging.LogProgressBar`: Progress bar logger
        &#34;&#34;&#34;
        name = [f&#39;{stage.capitalize()}&#39;]
        if step is not None and step_name is not None:
            name += [f&#39;{step_name.capitalize()} {step}&#39;]
        progress_bar_name = f&#39; {self._delimiter} &#39;.join(name)
        return LogProgressBar(self._logger, iterable, updates=updates, total=total,
                              name=progress_bar_name, delimiter=self._delimiter, **kwargs)

    def _log_summary(self, stage: str, metrics: dict,
                     step: tp.Optional[int] = None, step_name: str = &#34;epoch&#34;,
                     formatter: Formatter = Formatter()) -&gt; None:
        &#34;&#34;&#34;Log stage summary of current step with key metrics.

        Args:
            stage (str): Stage name
            metrics (dict): Dictionary of metrics to log (optionally already formatted)
            step (int): Number of current steps
            step_name (str): Name for the used steps (eg. `epochs`)
        &#34;&#34;&#34;
        out = [f&#39;{stage.capitalize()} Summary&#39;]
        if step is not None:
            out += [f&#39;{step_name.capitalize()} {step}&#39;]
        metrics = formatter(metrics)
        out += [f&#34;{key}={val}&#34;.strip() for key, val in metrics.items()]
        msg = f&#39; {self._delimiter} &#39;.join(out)
        self._logger.log(self._level, bold(msg))

    def log_metrics(self, stage: str, metrics: dict, step: tp.Optional[int] = None,
                    step_name: str = &#34;epoch&#34;,
                    formatter: Formatter = Formatter()) -&gt; None:
        &#34;&#34;&#34;Log metrics to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        self._log_summary(stage, metrics, step, step_name, formatter)
        for _, logger in self._experiment_loggers.items():
            logger.log_metrics(stage, metrics, step)

    def log_audio(self, stage: str, key: str, audio: tp.Any, sample_rate: int,
                  step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log audio to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_audio(stage, key, audio, sample_rate, step, **kwargs)

    def log_image(self, stage: str, key: str, image: tp.Any,
                  step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log image to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_image(stage, key, image, step, **kwargs)

    def log_text(self, stage: str, key: str, text: str, step: tp.Optional[int] = None, **kwargs) -&gt; None:
        &#34;&#34;&#34;Log text to all active experiment loggers.
        See `flashy.loggers.base.ExperimentLogger` for details.
        &#34;&#34;&#34;
        for _, logger in self._experiment_loggers.items():
            logger.log_text(stage, key, text, step, **kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="flashy.logging.ResultLogger.get_log_progress_bar"><code class="name flex">
<span>def <span class="ident">get_log_progress_bar</span></span>(<span>self, stage: str, iterable: collections.abc.Iterable, updates: int = 5, total: Optional[int] = None, step: Optional[int] = None, step_name: Optional[str] = None, **kwargs: Any) ‑> <a title="flashy.logging.LogProgressBar" href="#flashy.logging.LogProgressBar">LogProgressBar</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a progress bar logger formatted for the current stage and iterable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>str</code></dt>
<dd>Stage name</dd>
<dt><strong><code>iterable</code></strong> :&ensp;<code>Iterable</code></dt>
<dd>Data to iterate over</dd>
<dt><strong><code>updates</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of updates for the progress bar logging</dd>
<dt><strong><code>total</code></strong> :&ensp;<code>int</code></dt>
<dd>Total size of the data iterated over</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of current steps</dd>
<dt><strong><code>step_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name for the used steps (eg. <code>epochs</code>)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional arguments for :class:<code>~flashy.logging.LogProgressBar</code> initialization</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="flashy.logging.LogProgressBar" href="#flashy.logging.LogProgressBar">LogProgressBar</a></code>: Progress bar logger</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_log_progress_bar(self, stage: str, iterable: Iterable, updates: int = 5, total: tp.Optional[int] = None,
                         step: tp.Optional[int] = None, step_name: tp.Optional[str] = None,
                         **kwargs: tp.Any) -&gt; LogProgressBar:
    &#34;&#34;&#34;Get a progress bar logger formatted for the current stage and iterable.

    Args:
        stage (str): Stage name
        iterable (Iterable): Data to iterate over
        updates (int): Number of updates for the progress bar logging
        total (int): Total size of the data iterated over
        step (int): Number of current steps
        step_name (str): Name for the used steps (eg. `epochs`)
        kwargs: Additional arguments for :class:`~flashy.logging.LogProgressBar` initialization

    Returns:
        `flashy.logging.LogProgressBar`: Progress bar logger
    &#34;&#34;&#34;
    name = [f&#39;{stage.capitalize()}&#39;]
    if step is not None and step_name is not None:
        name += [f&#39;{step_name.capitalize()} {step}&#39;]
    progress_bar_name = f&#39; {self._delimiter} &#39;.join(name)
    return LogProgressBar(self._logger, iterable, updates=updates, total=total,
                          name=progress_bar_name, delimiter=self._delimiter, **kwargs)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.init_tensorboard"><code class="name flex">
<span>def <span class="ident">init_tensorboard</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Tensorboard logger using dora xp.
See <code><a title="flashy.loggers.tensorboard.TensorboardLogger.from_xp" href="loggers/tensorboard.html#flashy.loggers.tensorboard.TensorboardLogger.from_xp">TensorboardLogger.from_xp()</a></code> for details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_tensorboard(self, **kwargs):
    &#34;&#34;&#34;Initialize Tensorboard logger using dora xp.
    See `flashy.loggers.tensorboard.TensorboardLogger.from_xp` for details
    &#34;&#34;&#34;
    self._experiment_loggers[&#39;tensorboard&#39;] = TensorboardLogger.from_xp(**kwargs)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.init_wandb"><code class="name flex">
<span>def <span class="ident">init_wandb</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Wandb logger using dora xp.
See <code><a title="flashy.loggers.wandb.WandbLogger.from_xp" href="loggers/wandb.html#flashy.loggers.wandb.WandbLogger.from_xp">WandbLogger.from_xp()</a></code> for details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_wandb(self, **kwargs):
    &#34;&#34;&#34;Initialize Wandb logger using dora xp.
    See `flashy.loggers.wandb.WandbLogger.from_xp` for details
    &#34;&#34;&#34;
    self._experiment_loggers[&#39;wandb&#39;] = WandbLogger.from_xp(**kwargs)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.log_audio"><code class="name flex">
<span>def <span class="ident">log_audio</span></span>(<span>self, stage: str, key: str, audio: Any, sample_rate: int, step: Optional[int] = None, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log audio to all active experiment loggers.
See <code><a title="flashy.loggers.base.ExperimentLogger" href="loggers/base.html#flashy.loggers.base.ExperimentLogger">ExperimentLogger</a></code> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_audio(self, stage: str, key: str, audio: tp.Any, sample_rate: int,
              step: tp.Optional[int] = None, **kwargs) -&gt; None:
    &#34;&#34;&#34;Log audio to all active experiment loggers.
    See `flashy.loggers.base.ExperimentLogger` for details.
    &#34;&#34;&#34;
    for _, logger in self._experiment_loggers.items():
        logger.log_audio(stage, key, audio, sample_rate, step, **kwargs)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.log_hyperparams"><code class="name flex">
<span>def <span class="ident">log_hyperparams</span></span>(<span>self, params: Union[Dict[str, Any], argparse.Namespace], metrics: Optional[dict] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log hyperparameters to all active experiment loggers.
See <code><a title="flashy.loggers.base.ExperimentLogger" href="loggers/base.html#flashy.loggers.base.ExperimentLogger">ExperimentLogger</a></code> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_hyperparams(self, params: tp.Union[tp.Dict[str, tp.Any], Namespace],
                    metrics: tp.Optional[dict] = None) -&gt; None:
    &#34;&#34;&#34;Log hyperparameters to all active experiment loggers.
    See `flashy.loggers.base.ExperimentLogger` for details.
    &#34;&#34;&#34;
    for _, logger in self._experiment_loggers.items():
        logger.log_hyperparams(params, metrics)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.log_image"><code class="name flex">
<span>def <span class="ident">log_image</span></span>(<span>self, stage: str, key: str, image: Any, step: Optional[int] = None, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log image to all active experiment loggers.
See <code><a title="flashy.loggers.base.ExperimentLogger" href="loggers/base.html#flashy.loggers.base.ExperimentLogger">ExperimentLogger</a></code> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_image(self, stage: str, key: str, image: tp.Any,
              step: tp.Optional[int] = None, **kwargs) -&gt; None:
    &#34;&#34;&#34;Log image to all active experiment loggers.
    See `flashy.loggers.base.ExperimentLogger` for details.
    &#34;&#34;&#34;
    for _, logger in self._experiment_loggers.items():
        logger.log_image(stage, key, image, step, **kwargs)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.log_metrics"><code class="name flex">
<span>def <span class="ident">log_metrics</span></span>(<span>self, stage: str, metrics: dict, step: Optional[int] = None, step_name: str = 'epoch', formatter: <a title="flashy.formatter.Formatter" href="formatter.html#flashy.formatter.Formatter">Formatter</a> = &lt;flashy.formatter.Formatter object&gt;) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log metrics to all active experiment loggers.
See <code><a title="flashy.loggers.base.ExperimentLogger" href="loggers/base.html#flashy.loggers.base.ExperimentLogger">ExperimentLogger</a></code> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_metrics(self, stage: str, metrics: dict, step: tp.Optional[int] = None,
                step_name: str = &#34;epoch&#34;,
                formatter: Formatter = Formatter()) -&gt; None:
    &#34;&#34;&#34;Log metrics to all active experiment loggers.
    See `flashy.loggers.base.ExperimentLogger` for details.
    &#34;&#34;&#34;
    self._log_summary(stage, metrics, step, step_name, formatter)
    for _, logger in self._experiment_loggers.items():
        logger.log_metrics(stage, metrics, step)</code></pre>
</details>
</dd>
<dt id="flashy.logging.ResultLogger.log_text"><code class="name flex">
<span>def <span class="ident">log_text</span></span>(<span>self, stage: str, key: str, text: str, step: Optional[int] = None, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log text to all active experiment loggers.
See <code><a title="flashy.loggers.base.ExperimentLogger" href="loggers/base.html#flashy.loggers.base.ExperimentLogger">ExperimentLogger</a></code> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_text(self, stage: str, key: str, text: str, step: tp.Optional[int] = None, **kwargs) -&gt; None:
    &#34;&#34;&#34;Log text to all active experiment loggers.
    See `flashy.loggers.base.ExperimentLogger` for details.
    &#34;&#34;&#34;
    for _, logger in self._experiment_loggers.items():
        logger.log_text(stage, key, text, step, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flashy" href="index.html">flashy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="flashy.logging.bold" href="#flashy.logging.bold">bold</a></code></li>
<li><code><a title="flashy.logging.colorize" href="#flashy.logging.colorize">colorize</a></code></li>
<li><code><a title="flashy.logging.setup_logging" href="#flashy.logging.setup_logging">setup_logging</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flashy.logging.LogProgressBar" href="#flashy.logging.LogProgressBar">LogProgressBar</a></code></h4>
<ul class="">
<li><code><a title="flashy.logging.LogProgressBar.update" href="#flashy.logging.LogProgressBar.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="flashy.logging.ResultLogger" href="#flashy.logging.ResultLogger">ResultLogger</a></code></h4>
<ul class="">
<li><code><a title="flashy.logging.ResultLogger.get_log_progress_bar" href="#flashy.logging.ResultLogger.get_log_progress_bar">get_log_progress_bar</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.init_tensorboard" href="#flashy.logging.ResultLogger.init_tensorboard">init_tensorboard</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.init_wandb" href="#flashy.logging.ResultLogger.init_wandb">init_wandb</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.log_audio" href="#flashy.logging.ResultLogger.log_audio">log_audio</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.log_hyperparams" href="#flashy.logging.ResultLogger.log_hyperparams">log_hyperparams</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.log_image" href="#flashy.logging.ResultLogger.log_image">log_image</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.log_metrics" href="#flashy.logging.ResultLogger.log_metrics">log_metrics</a></code></li>
<li><code><a title="flashy.logging.ResultLogger.log_text" href="#flashy.logging.ResultLogger.log_text">log_text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>